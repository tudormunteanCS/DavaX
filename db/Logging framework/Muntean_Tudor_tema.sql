-- get familiar with data query :)
select EMPLOYEE_ID,SALARY, COMMISSION_PCT, FIRST_NAME from employees where COMMISSION_PCT IS NOT NULL

CREATE TABLE debug_log (
    log_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    log_time TIMESTAMP DEFAULT SYSTIMESTAMP,
    module_name VARCHAR2(100),
    line_no NUMBER,
    log_message VARCHAR2(4000),
    session_id VARCHAR2(50) DEFAULT SYS_CONTEXT('USERENV', 'SESSIONID')
);

/*adaugam o coloana noua pentru tabel pentru a beneficia de extendirea frameworkului prin
permisia de filtrari ale nivelului fiecarui log
INFO - Evenimente normale, informative (ex: „Procedura X a pornit”)
WARN	Situații neașteptate, dar care nu întrerup execuția
ERROR	Erori critice care afectează execuția și trebuie investigate
*/
ALTER TABLE debug_log ADD (log_level VARCHAR2(10));

CREATE OR REPLACE PACKAGE debug_utils IS
    g_debug_mode BOOLEAN := FALSE;
    PROCEDURE enable_debug; --set debug_mode to TRUE
    PROCEDURE disable_debug; --set debug_mode to FALSE
    
    PROCEDURE log_msg(p_message VARCHAR2,p_module_name VARCHAR2, p_line_no NUMBER, p_level VARCHAR2);
    PROCEDURE log_error (p_err VARCHAR2,p_module_name VARCHAR2, p_line_no NUMBER);
    
END debug_utils;

CREATE OR REPLACE PACKAGE BODY debug_utils IS
    PROCEDURE enable_debug IS
    BEGIN
        g_debug_mode := TRUE;
    END;
    
    PROCEDURE disable_debug IS
    BEGIN
        g_debug_mode := FALSE;
    END;
    
    PROCEDURE log_msg(p_message VARCHAR2,p_module_name VARCHAR2, p_line_no NUMBER, p_level VARCHAR2) IS
    BEGIN
      IF g_debug_mode THEN
         INSERT INTO debug_log(module_name,line_no,log_message,log_level)
         VALUES (p_module_name,p_line_no,p_message,p_level);
      END IF;
   
    END;

   PROCEDURE log_error(p_err VARCHAR2,p_module_name VARCHAR2, p_line_no NUMBER) IS
   BEGIN
      log_msg('[ERROR] ' || p_err,p_module_name,p_line_no, 'ERROR');
   END;
END debug_utils;


CREATE OR REPLACE PROCEDURE adjust_salaries_by_commission IS
 v_module_name VARCHAR2(100) := 'adjust_salaries_by_commission';
 v_line_no NUMBER;
 v_message VARCHAR2(4000);
 v_new_salary NUMBER;
 
BEGIN
    debug_utils.enable_debug;
    for emp_rec IN(
        SELECT EMPLOYEE_ID, SALARY, COMMISSION_PCT
        FROM EMPLOYEES)
    LOOP
    BEGIN
        v_line_no := 12;
        IF emp_rec.COMMISSION_PCT IS NOT NULL THEN
            v_line_no := 17;
            v_new_salary := emp_rec.SALARY * (1 + emp_rec.COMMISSION_PCT);
        ELSE
            v_line_no := 20;
            v_new_salary := emp_rec.SALARY * 1.02;
        END IF;
        
        v_line_no := 24;
        UPDATE employees
        SET SALARY = v_new_salary
        WHERE EMPLOYEE_ID = emp_rec.EMPLOYEE_ID;
        
        v_line_no := 28;
        v_message := 'Salary adjusted for EMPLOYEE_ID=' || emp_rec.EMPLOYEE_ID || 
                             ' to ' || TO_CHAR(v_new_salary);
        debug_utils.log_msg(v_message, v_module_name, v_line_no, 'INFO');
        EXCEPTION
            WHEN OTHERS THEN
                v_line_no := 33;
                debug_utils.log_error(SQLERRM, v_module_name, v_line_no);
    END;
    END LOOP;
    
    v_line_no := 38;
    debug_utils.log_msg('Procedure completed successfully.', v_module_name, v_line_no, 'INFO');
        
END;




select EMPLOYEE_ID,SALARY, COMMISSION_PCT, FIRST_NAME from employees where COMMISSION_PCT IS NOT NULL

EXEC adjust_salaries_by_commission --test; it worked!

-- Voi folosi DBMS_UTILITY.FORMAT_CALL_STACK pentru a automatiza obținerea numelui modulului și liniei

/* nu am putut parsa corect ce a returnat DBMS_UTILITY.FORMAT_CALL_STACK folosind chatgpt  & gemini
nici pe internet nu am gasit nimic, dar voi mai incerca pentru a putea automatiza selectarea numelui modulului si numarul liniei din procedura
*/
--CREATE OR REPLACE PACKAGE debug_utils_v2 IS
--   g_debug_mode BOOLEAN := TRUE;
--   PROCEDURE log_msg(p_message VARCHAR2, p_level VARCHAR2 := 'INFO');
--   PROCEDURE log_error(p_err VARCHAR2);
--END debug_utils;
--/
--
--CREATE OR REPLACE PACKAGE BODY debug_utils_v2 IS
--
--   PROCEDURE log_msg(p_message VARCHAR2, p_level VARCHAR2 := 'INFO') IS
--      v_stack   VARCHAR2(4000);
--      v_module  VARCHAR2(100);
--      v_line    NUMBER;
--   BEGIN
--      IF g_debug_mode THEN
--         v_stack := DBMS_UTILITY.FORMAT_CALL_STACK;
--
--         -- Parse modul și linia (extragem a doua linie semnificativă)
--         SELECT REGEXP_SUBSTR(v_stack, 'package body (.+?) line (\d+)', 1, 1, NULL, 1),
--                TO_NUMBER(REGEXP_SUBSTR(v_stack, 'line (\d+)', 1, 1, NULL, 1))
--         INTO v_module, v_line
--         FROM dual
--         WHERE REGEXP_LIKE(v_stack, 'package body');
--
--         INSERT INTO debug_log(log_level, module_name, line_no, log_message)
--         VALUES (p_level, v_module, v_line, p_message);
--      END IF;
--   EXCEPTION
--      WHEN OTHERS THEN
--         -- Fallback basic log if parsing fails
--         INSERT INTO debug_log(log_level, module_name, line_no, log_message)
--         VALUES (p_level, 'UNKNOWN', NULL, p_message);
--   END;
--
--   PROCEDURE log_error(p_err VARCHAR2) IS
--   BEGIN
--      log_msg('[ERROR] ' || p_err, 'ERROR');
--   END;
--
--END debug_utils;
--/


